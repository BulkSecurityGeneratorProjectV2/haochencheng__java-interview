## redis


### redis 键过期机制
https://github.com/antirez/redis/blob/a92921da135e38eedd89138e15fe9fd1ffdd9b48/src/expire.c#L98
https://redis.io/commands/expire

#####   定期删除/主动删除
redis每隔100ms（每秒10次）去有过期属性的键集合中随机抽取20个key测试，查看是否过期，
将过期的键删除，如果20个key中超过25%都过期了。继续抽取20个key进行测试。
这意味着在任何给定时刻，正在使用内存的已过期密钥的最大数量最大等于每秒最大写操作数量除以4。

优点：节省cpu资源
缺点：可能有的key过期了未被删除
#####   惰性删除/被动删除
在客户端获取key的时候判断是否过期，过期就删除。

优点：节省cpu资源
缺点：大量key过期但是没有访问会占用大量内存

#####   持久化处理过期
- AOF     
从内存数据库持久化数据到AOF文件：当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
AOF重写：重写时，会先判断key是否过期，已过期的key不会重写到aof文件

- RDB           
从内存数据库持久化数据到RDB文件：持久化key之前，会检查是否过期，过期的key不进入RDB文件 从RDB文件恢复数据到内存数据库：数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。

#####   内存淘汰机制
但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，占用内存，长期下去可能会导致内存耗尽。

```
# maxmemory <bytes> 配置内存阈值
# maxmemory-policy noeviction 
```
淘汰策略
```$xslt
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

```